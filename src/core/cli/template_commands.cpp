#include "ssmtp-mailer/cli_commands.hpp"
#include "../logging/logger.hpp"
#include <iostream>
#include <fstream>
#include <sstream>
#include <filesystem>
#include <ctime>
#include <iomanip>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"

namespace ssmtp_mailer {

namespace {
    std::string getCurrentTimestamp() {
        auto now = std::time(nullptr);
        auto tm = *std::localtime(&now);
        
        std::ostringstream oss;
        oss << std::put_time(&tm, "%Y-%m-%d %H:%M:%S");
        return oss.str();
    }
}

// Template command implementations

CLIResult TemplateCommands::createTemplate(const std::vector<std::string>& args) {
        if (args.size() < 5) {
            return CLIResult::error_result("Usage: template create <name> --subject <subject> --body <body> [--html <html>]");
        }
        
        std::string name = args[0];
        std::string subject;
        std::string body;
        std::string html;
        std::string description;
        
        // Parse arguments
        for (size_t i = 1; i < args.size(); ++i) {
            if (args[i] == "--subject" && i + 1 < args.size()) {
                subject = args[++i];
            } else if (args[i] == "--body" && i + 1 < args.size()) {
                body = args[++i];
            } else if (args[i] == "--html" && i + 1 < args.size()) {
                html = args[++i];
            } else if (args[i] == "--description" && i + 1 < args.size()) {
                description = args[++i];
            }
        }
        
        if (subject.empty() || body.empty()) {
            return CLIResult::error_result("Both --subject and --body are required");
        }
        
        try {
            // Create templates directory
            std::string templates_dir = "/etc/ssmtp-mailer/templates";
            std::filesystem::create_directories(templates_dir);
            
            // Create template file
            std::string template_file = templates_dir + "/" + name + ".conf";
            std::ofstream file(template_file);
            
            if (!file.is_open()) {
                return CLIResult::error_result("Failed to create template file: " + template_file);
            }
            
            file << "# Email Template: " << name << "\n";
            file << "# Generated by ssmtp-mailer CLI\n\n";
            if (!description.empty()) {
                file << "# Description: " << description << "\n\n";
            }
            
            file << "[template:" << name << "]\n";
            file << "name = " << name << "\n";
            file << "subject = " << subject << "\n";
            file << "body = " << body << "\n";
            if (!html.empty()) {
                file << "html_body = " << html << "\n";
            }
            file << "enabled = true\n";
            file << "created = " << getCurrentTimestamp() << "\n";
            
            file.close();
            
            return CLIResult::success_result("Template '" + name + "' created successfully at " + template_file);
            
        } catch (const std::exception& e) {
            return CLIResult::error_result("Failed to create template: " + std::string(e.what()));
        }
    }
    
CLIResult TemplateCommands::listTemplates(const std::vector<std::string>& args) {
        std::string templates_dir = "/etc/ssmtp-mailer/templates";
        
        try {
            if (!std::filesystem::exists(templates_dir)) {
                std::cout << "No templates configured.\n";
                return CLIResult::success_result();
            }
            
            std::cout << "Available templates:\n";
            for (const auto& entry : std::filesystem::directory_iterator(templates_dir)) {
                if (entry.is_regular_file() && entry.path().extension() == ".conf") {
                    std::string name = entry.path().stem().string();
                    
                    // Read template info
                    std::ifstream file(entry.path());
                    std::string line;
                    std::string description;
                    bool enabled = true;
                    
                    while (std::getline(file, line)) {
                        if (line.find("# Description: ") == 0) {
                            description = line.substr(15);
                        } else if (line.find("enabled = ") == 0) {
                            enabled = (line.substr(10) == "true");
                        }
                    }
                    
                    std::cout << "  " << name;
                    if (!description.empty()) {
                        std::cout << " - " << description;
                    }
                    std::cout << " (" << (enabled ? "enabled" : "disabled") << ")\n";
                }
            }
            
            return CLIResult::success_result();
            
        } catch (const std::exception& e) {
            return CLIResult::error_result("Failed to list templates: " + std::string(e.what()));
        }
    }
    
CLIResult TemplateCommands::showTemplate(const std::vector<std::string>& args) {
        if (args.empty()) {
            return CLIResult::error_result("Usage: template show <name>");
        }
        
        std::string name = args[0];
        std::string template_file = "/etc/ssmtp-mailer/templates/" + name + ".conf";
        
        try {
            if (!std::filesystem::exists(template_file)) {
                return CLIResult::error_result("Template not found: " + name);
            }
            
            std::ifstream file(template_file);
            if (!file.is_open()) {
                return CLIResult::error_result("Failed to read template file");
            }
            
            std::cout << "Template: " << name << "\n";
            std::cout << "==================\n";
            
            std::string line;
            while (std::getline(file, line)) {
                if (line.empty() || line[0] == '#') continue;
                
                size_t pos = line.find('=');
                if (pos != std::string::npos) {
                    std::string key = line.substr(0, pos);
                    std::string value = line.substr(pos + 1);
                    
                    // Trim whitespace
                    key.erase(0, key.find_first_not_of(" \t"));
                    key.erase(key.find_last_not_of(" \t") + 1);
                    value.erase(0, value.find_first_not_of(" \t"));
                    value.erase(value.find_last_not_of(" \t") + 1);
                    
                    std::cout << "  " << key << ": " << value << "\n";
                }
            }
            
            return CLIResult::success_result();
            
        } catch (const std::exception& e) {
            return CLIResult::error_result("Failed to show template: " + std::string(e.what()));
        }
    }
    
CLIResult TemplateCommands::testTemplate(const std::vector<std::string>& args) {
        if (args.size() < 3) {
            return CLIResult::error_result("Usage: template test <name> --to <email> [--from <email>]");
        }
        
        std::string name = args[0];
        std::string to_email;
        std::string from_email = "test@example.com";
        
        // Parse arguments
        for (size_t i = 1; i < args.size(); ++i) {
            if (args[i] == "--to" && i + 1 < args.size()) {
                to_email = args[++i];
            } else if (args[i] == "--from" && i + 1 < args.size()) {
                from_email = args[++i];
            }
        }
        
        if (to_email.empty()) {
            return CLIResult::error_result("--to email is required");
        }
        
        std::string template_file = "/etc/ssmtp-mailer/templates/" + name + ".conf";
        
        try {
            if (!std::filesystem::exists(template_file)) {
                return CLIResult::error_result("Template not found: " + name);
            }
            
            std::ifstream file(template_file);
            if (!file.is_open()) {
                return CLIResult::error_result("Failed to read template file");
            }
            
            std::string line;
            std::string subject;
            std::string body;
            std::string html_body;
            
            while (std::getline(file, line)) {
                if (line.find("subject = ") == 0) {
                    subject = line.substr(10);
                } else if (line.find("body = ") == 0) {
                    body = line.substr(7);
                } else if (line.find("html_body = ") == 0) {
                    html_body = line.substr(12);
                }
            }
            
            file.close();
            
            if (subject.empty() || body.empty()) {
                return CLIResult::error_result("Template is missing required fields (subject or body)");
            }
            
            std::cout << "Template Test: " << name << "\n";
            std::cout << "============================\n";
            std::cout << "From: " << from_email << "\n";
            std::cout << "To: " << to_email << "\n";
            std::cout << "Subject: " << subject << "\n";
            std::cout << "Body:\n" << body << "\n";
            if (!html_body.empty()) {
                std::cout << "HTML Body:\n" << html_body << "\n";
            }
            
            return CLIResult::success_result();
            
        } catch (const std::exception& e) {
            return CLIResult::error_result("Failed to test template: " + std::string(e.what()));
        }
    }
    
CLIResult TemplateCommands::createAddressTemplate(const std::vector<std::string>& args) {
        if (args.size() < 5) {
            return CLIResult::error_result("Usage: template address create <pattern> --domain <domain> --types <types>");
        }
        
        std::string pattern = args[0];
        std::string domain;
        std::vector<std::string> types;
        
        // Parse arguments
        for (size_t i = 1; i < args.size(); ++i) {
            if (args[i] == "--domain" && i + 1 < args.size()) {
                domain = args[++i];
            } else if (args[i] == "--types" && i + 1 < args.size()) {
                // Parse comma-separated types
                std::string types_str = args[++i];
                std::istringstream ss(types_str);
                std::string type;
                while (std::getline(ss, type, ',')) {
                    type.erase(0, type.find_first_not_of(" \t"));
                    type.erase(type.find_last_not_of(" \t") + 1);
                    if (!type.empty()) {
                        types.push_back(type);
                    }
                }
            }
        }
        
        if (domain.empty() || types.empty()) {
            return CLIResult::error_result("Both --domain and --types are required");
        }
        
        try {
            // Create address templates directory
            std::string templates_dir = "/etc/ssmtp-mailer/address-templates";
            std::filesystem::create_directories(templates_dir);
            
            // Create address template file
            std::string template_file = templates_dir + "/" + pattern + ".conf";
            std::ofstream file(template_file);
            
            if (!file.is_open()) {
                return CLIResult::error_result("Failed to create address template file: " + template_file);
            }
            
            file << "# Address Template: " << pattern << "\n";
            file << "# Generated by ssmtp-mailer CLI\n\n";
            
            file << "[address_template:" << pattern << "]\n";
            file << "pattern = " << pattern << "\n";
            file << "domain = " << domain << "\n";
            file << "template_address = true\n";
            file << "enabled = true\n";
            file << "created = " << getCurrentTimestamp() << "\n";
            
            file << "allowed_types = [";
            for (size_t i = 0; i < types.size(); ++i) {
                if (i > 0) file << ", ";
                file << "\"" << types[i] << "\"";
            }
            file << "]\n";
            
            file.close();
            
            return CLIResult::success_result("Address template '" + pattern + "' created successfully at " + template_file);
            
        } catch (const std::exception& e) {
            return CLIResult::error_result("Failed to create address template: " + std::string(e.what()));
        }
    }
    
CLIResult TemplateCommands::listAddressTemplates(const std::vector<std::string>& args) {
        std::string templates_dir = "/etc/ssmtp-mailer/address-templates";
        
        try {
            if (!std::filesystem::exists(templates_dir)) {
                std::cout << "No address templates configured.\n";
                return CLIResult::success_result();
            }
            
            std::cout << "Available address templates:\n";
            for (const auto& entry : std::filesystem::directory_iterator(templates_dir)) {
                if (entry.is_regular_file() && entry.path().extension() == ".conf") {
                    std::string name = entry.path().stem().string();
                    
                    // Read template info
                    std::ifstream file(entry.path());
                    std::string line;
                    std::string domain;
                    bool enabled = true;
                    
                    while (std::getline(file, line)) {
                        if (line.find("domain = ") == 0) {
                            domain = line.substr(9);
                        } else if (line.find("enabled = ") == 0) {
                            enabled = (line.substr(10) == "true");
                        }
                    }
                    
                    std::cout << "  " << name << " -> " << domain;
                    std::cout << " (" << (enabled ? "enabled" : "disabled") << ")\n";
                }
            }
            
            return CLIResult::success_result();
            
        } catch (const std::exception& e) {
            return CLIResult::error_result("Failed to list address templates: " + std::string(e.what()));
        }
    }

} // namespace ssmtp_mailer

#pragma clang diagnostic pop
